{"version":3,"sources":["../src/index.ts","../src/commands/init.ts","../src/templates/manager.ts","../src/toolchains/go.ts","../src/utils/logger.ts","../src/toolchains/java.ts","../src/toolchains/index.ts"],"sourcesContent":["import { Command } from 'commander';\nimport { initCommand } from './commands/init';\nimport { createLogger } from './utils/logger';\n\nconst logger = createLogger();\n\nconst program = new Command()\n    .name('eden')\n    .description('Modern project scaffolding tool')\n    .version('0.1.0');\n\nprogram\n    .command('init [output]')\n    .description('Initialize a new project in the specified directory or current directory with \".\"')\n    .option('-l, --language <language>', 'Target language')\n    .option('-t, --type <type>', 'Project type')\n    .action(async (output, options) => {\n        try {\n            await initCommand({ ...options, output });\n        } catch (error) {\n            logger.error('Failed to initialize project:', error);\n            process.exit(1);\n        }\n    });\n\nprogram.parse();","import { select, input } from '@inquirer/prompts';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport { TemplateManager } from '../templates/manager';\nimport { getToolchain } from '../toolchains';\nimport { createLogger } from '../utils/logger';\nimport { TemplateConfig } from '../types';\nimport chalk from 'chalk';\nimport fs from 'fs/promises';\n\nconst logger = createLogger();\n\n// Get the directory where our package is installed\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n// Remove one level of \"..\" since we're already in the right directory\nconst pkgRoot = path.resolve(__dirname, '..');\n\ninterface InitOptions {\n    language?: string;\n    type?: string;\n    output?: string;\n}\n\nexport async function initCommand(options: InitOptions): Promise<void> {\n    const templatesPath = path.join(pkgRoot, 'templates');\n    const templateManager = new TemplateManager(templatesPath);\n\n    try {\n        // Get available templates\n        const templates = await templateManager.listAvailableTemplates();\n\n        // If language not provided, prompt for it\n        let language = options.language || await promptLanguage(templates);\n        language = language.toLowerCase();\n\n        // Get available types for selected language\n        const languageTemplates = templates.find(t => t.language === language);\n        if (!languageTemplates) {\n            throw new Error(`No templates available for language: ${language}`);\n        }\n\n        // If type not provided, prompt for it\n        let type = options.type || await promptType(languageTemplates.types);\n        type = type.toLowerCase();\n\n        // Load template config\n        logger.info('Loading template configuration...');\n        const config = await templateManager.getTemplateConfig(language, type);\n\n        // Prompt for variables\n        const variables = await promptVariables(config);\n\n        ///////////////////////////////////////////////////////////////////////////////\n\n        // Determine project directory\n        const outputPath = options.output ?\n            (options.output === '.' ? process.cwd() : path.resolve(options.output)) :\n            path.join(process.cwd(), variables.project_name);\n\n        // Verify directory\n        const exists = await directoryExists(outputPath);\n        if (exists) {\n            if (outputPath === process.cwd()) {\n                logger.info('Using current directory');\n            } else {\n                throw new Error(`Directory ${outputPath} already exists`);\n            }\n        } else {\n            await fs.mkdir(outputPath, { recursive: true });\n        }\n\n        ///////////////////////////////////////////////////////////////////////////////\n\n        // Process template files\n        const templatePath = templateManager.getTemplatePath(language, type);\n        await templateManager.processTemplate(templatePath, outputPath, variables);\n\n        // Initialize toolchain\n        const toolchain = getToolchain(language);\n        if (!toolchain) {\n            throw new Error(`No toolchain available for language: ${language}`);\n        }\n\n        // Validate environment\n        logger.info('Validating environment...');\n        const isValid = await toolchain.validateEnvironment();\n        if (!isValid) {\n            throw new Error(`Environment validation failed for ${language}`);\n        }\n\n        // Run toolchain steps\n        logger.info('Initializing project...');\n        await toolchain.initialize(outputPath, variables);\n\n        logger.info('Installing dependencies...');\n        await toolchain.installDependencies(outputPath);\n\n        logger.info('Setting up tests...');\n        await toolchain.setupTests(outputPath);\n\n        logger.success('Project created successfully!');\n\n        // Print next steps\n        logger.info('\\nNext steps:');\n\n        const stylizedOutputPath: string | undefined = outputPath\n            .split('/')\n            .pop();\n\n        if (options.output !== '.') {\n            logger.info(chalk.cyan(`  cd ${stylizedOutputPath}`));\n        }\n\n        if (language === 'go') {\n            logger.info(chalk.cyan('  go mod tidy'));\n            logger.info(chalk.cyan('  go run main.go'));\n        } else if (language === 'java') {\n            logger.info(chalk.cyan('  gradle quarkusDev'));\n        }\n    } catch (error) {\n        logger.error('Failed to initialize project:', error);\n        process.exit(1);\n    }\n}\n\nasync function promptLanguage(templates: Array<{ language: string; types: string[] }>): Promise<string> {\n    return select({\n        message: 'Select a language:',\n        choices: templates.map(t => ({\n            value: capitalize(t.language),\n            label: capitalize(t.language)\n        }))\n    });\n}\n\nasync function promptType(types: string[]): Promise<string> {\n    return select({\n        message: 'Select a project type:',\n        choices: types.map(type => ({\n            value: capitalize(type),\n            label: capitalize(type)\n        }))\n    });\n}\n\nasync function promptVariables(config: TemplateConfig): Promise<Record<string, string>> {\n    const variables: Record<string, string> = {};\n\n    for (const variable of config.variables) {\n        const value = await input({\n            message: variable.prompt,\n            default: variable.default,\n            validate: variable.validate ?\n                (input: string) => {\n                    if (typeof variable.validate === 'string') {\n                        // If validate is a regex string\n                        const regex = new RegExp(variable.validate);\n                        return regex.test(input) || `Input must match pattern: ${variable.validate}`;\n                    }\n                    // If validate is a function (which it shouldn't be in YAML)\n                    return true;\n                } : undefined\n        });\n        variables[variable.name] = value;\n    }\n\n    return variables;\n}\n\nasync function directoryExists(dir: string): Promise<boolean> {\n    try {\n        const stats = await fs.stat(dir);\n        return stats.isDirectory();\n    } catch {\n        return false;\n    }\n}\n\nfunction capitalize(value: string): string {\n    return String(value).charAt(0).toUpperCase() + String(value).slice(1);\n}","// src/templates/manager.ts\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { parse as parseYaml } from 'yaml';\nimport mustache from 'mustache';\nimport { TemplateConfig, TemplateProvider } from '../types';\n\nmustache.escape = (text) => text;\n\nexport class TemplateManager implements TemplateProvider {\n    constructor(private readonly templatesPath: string) { }\n\n    async getTemplateConfig(language: string, type: string): Promise<TemplateConfig> {\n        const templatePath = path.join(this.templatesPath, language, type);\n        const configPath = path.join(templatePath, 'template.yaml');\n\n        try {\n            const configContent = await fs.readFile(configPath, 'utf-8');\n            return parseYaml(configContent) as TemplateConfig;\n        } catch (error) {\n            throw new Error(`Failed to load template config for ${language}/${type}: ${error}`);\n        }\n    }\n\n    getTemplatePath(language: string, type: string): string {\n        return path.join(this.templatesPath, language, type, 'files');\n    }\n\n    async listAvailableTemplates(): Promise<Array<{ language: string; types: string[] }>> {\n        const languages = await fs.readdir(this.templatesPath);\n\n        const templates = await Promise.all(\n            languages.map(async (language) => {\n                const languagePath = path.join(this.templatesPath, language);\n                const stats = await fs.stat(languagePath);\n\n                if (!stats.isDirectory()) return null;\n\n                const types = await fs.readdir(languagePath);\n                const validTypes = await Promise.all(\n                    types.map(async (type) => {\n                        const configPath = path.join(languagePath, type, 'template.yaml');\n                        try {\n                            await fs.access(configPath);\n                            return type;\n                        } catch {\n                            return null;\n                        }\n                    })\n                );\n\n                return {\n                    language,\n                    types: validTypes.filter((type): type is string => type !== null),\n                };\n            })\n        );\n\n        return templates.filter((t): t is { language: string; types: string[] } => t !== null);\n    }\n\n    async processTemplate(\n        sourcePath: string,\n        targetPath: string,\n        variables: Record<string, string>\n    ): Promise<void> {\n        await fs.mkdir(targetPath, { recursive: true });\n        const entries = await fs.readdir(sourcePath, { withFileTypes: true });\n\n        for (const entry of entries) {\n            const sourceFilePath = path.join(sourcePath, entry.name);\n            // Process filename for potential variables\n            const targetFileName = mustache.render(entry.name, variables);\n            const targetFilePath = path.join(targetPath, targetFileName);\n\n            if (entry.isDirectory()) {\n                await this.processTemplate(sourceFilePath, targetFilePath, variables);\n            } else {\n                let content = await fs.readFile(sourceFilePath, 'utf-8');\n                // Fix for Go imports: convert {{.module_path}} to {{module_path}}\n                content = content.replace(/\\{\\{\\s*\\.module_path\\s*\\}\\}/g, '{{module_path}}');\n                const processedContent = mustache.render(content, variables);\n                await fs.writeFile(targetFilePath, processedContent);\n            }\n        }\n    }\n}","import { exec } from 'child_process';\nimport { promisify } from 'util';\nimport { Toolchain } from '../types';\nimport { createLogger } from '../utils/logger';\n\nconst execAsync = promisify(exec);\nconst logger = createLogger();\n\nexport class GoToolchain implements Toolchain {\n    name = 'go';\n\n    async validateEnvironment(): Promise<boolean> {\n        try {\n            await execAsync('go version');\n            return true;\n        } catch {\n            logger.error('Go is not installed or not in PATH', '');\n            return false;\n        }\n    }\n\n    async initialize(projectPath: string, options: Record<string, string>): Promise<void> {\n        const modulePath = options.module_path || options.project_name;\n        await execAsync(`go mod init ${modulePath}`, { cwd: projectPath });\n    }\n\n    async installDependencies(projectPath: string): Promise<void> {\n        await execAsync('go mod tidy', { cwd: projectPath });\n    }\n\n    async setupTests(projectPath: string): Promise<void> {\n        // Basic test setup - will be populated by template\n        await execAsync('mkdir -p internal', { cwd: projectPath });\n    }\n}","import chalk from 'chalk';\n\nexport function createLogger() {\n    return {\n        info: (message: string, ...args: unknown[]) => {\n            console.info(message, ...args);\n        },\n        error: (message: string, error: unknown) => {\n            console.error(chalk.red(message), error instanceof Error ? error.message : error);\n        },\n        success: (message: string) => {\n            console.info(chalk.green('✓'), message);\n        },\n        warn: (message: string) => {\n            console.warn(chalk.yellow('⚠'), message);\n        }\n    };\n}","// src/toolchains/java.ts\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport { Toolchain } from '../types';\nimport { createLogger } from '../utils/logger';\nimport fs from 'fs/promises';\nimport path from 'path';\n\nconst execAsync = promisify(exec);\nconst logger = createLogger();\n\nexport class JavaToolchain implements Toolchain {\n    name = 'java';\n\n    async validateEnvironment(): Promise<boolean> {\n        try {\n            // Check for Java installation\n            const { stderr: javaVersion } = await execAsync('java -version');\n            logger.info('Found Java:', javaVersion.split('\\n')[0]);\n\n            // Check for Gradle installation\n            const { stdout: gradleVersion } = await execAsync('gradle --version');\n            const gradleVersionLine = gradleVersion.split('\\n').find(line => line.includes('Gradle'));\n            if (gradleVersionLine) {\n                logger.info('Found Gradle:', gradleVersionLine.trim());\n            }\n\n            return true;\n        } catch (error) {\n            if (error instanceof Error) {\n                const message = error.message.toLowerCase();\n                if (message.includes('java')) {\n                    logger.error('Java is not installed or not in PATH', '');\n                } else if (message.includes('gradle')) {\n                    logger.error('Gradle is not installed or not in PATH', '');\n                }\n            }\n            return false;\n        }\n    }\n\n    async initialize(projectPath: string, options: Record<string, string>): Promise<void> {\n        const packagePath = options.package_name.replace(/\\./g, '/');\n\n        // Create package directory structure\n        const srcPath = path.join(projectPath, 'src', 'main', 'java', packagePath);\n        const testPath = path.join(projectPath, 'src', 'test', 'java', packagePath);\n\n        await fs.mkdir(srcPath, { recursive: true });\n        await fs.mkdir(testPath, { recursive: true });\n\n        // Move Java files from root src/main/java to correct package directory\n        try {\n            const mainJavaDir = path.join(projectPath, 'src', 'main', 'java');\n            const files = await fs.readdir(mainJavaDir);\n\n            for (const file of files) {\n                if (file.endsWith('.java')) {\n                    const oldPath = path.join(mainJavaDir, file);\n                    const newPath = path.join(srcPath, file);\n                    await fs.rename(oldPath, newPath);\n                }\n            }\n        } catch (error) {\n            logger.error('Error moving Java files to package directory:', error);\n        }\n\n        // Download Gradle wrapper if Gradle is not installed\n        try {\n            await execAsync('gradle --version');\n            logger.info('Using system Gradle installation');\n        } catch {\n            logger.info('Gradle not found, downloading wrapper...');\n            await this.downloadGradleWrapper(projectPath);\n        }\n    }\n\n    private async downloadGradleWrapper(projectPath: string): Promise<void> {\n        const gradleVersion = '8.5';  // Latest stable version\n        try {\n            // Try to use system Gradle to create wrapper\n            await execAsync(\n                `gradle wrapper --gradle-version ${gradleVersion} --distribution-type bin`,\n                { cwd: projectPath }\n            );\n            await fs.chmod(path.join(projectPath, 'gradlew'), 0o755);\n        } catch (error) {\n            logger.warn('Could not download Gradle wrapper automatically.');\n            // Create placeholder gradle wrapper script\n            const gradlewContent = `#!/bin/sh\necho \"Please install Gradle ${gradleVersion} or run 'gradle wrapper' to download the wrapper.\"\nexit 1`;\n            await fs.writeFile(path.join(projectPath, 'gradlew'), gradlewContent);\n            await fs.chmod(path.join(projectPath, 'gradlew'), 0o755);\n        }\n    }\n\n    async installDependencies(projectPath: string): Promise<void> {\n        try {\n            logger.info('Building project and downloading dependencies...');\n            // Try using system Gradle first, fall back to wrapper\n            try {\n                await execAsync('gradle build -x test', { cwd: projectPath });\n            } catch {\n                await execAsync('./gradlew build -x test', { cwd: projectPath });\n            }\n        } catch (error) {\n            throw new Error(`Failed to build project: ${error}`);\n        }\n    }\n\n    async setupTests(projectPath: string): Promise<void> {\n        logger.info('Test environment ready. Run ./gradlew test to execute tests.');\n    }\n}","import { GoToolchain } from './go';\nimport { Toolchain } from '../types';\nimport { JavaToolchain } from './java';\n\nconst toolchains: Record<string, Toolchain> = {\n    go: new GoToolchain(),\n    java: new JavaToolchain(),\n};\n\nexport function getToolchain(language: string): Toolchain | undefined {\n    return toolchains[language];\n}"],"mappings":"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","names":["Command","select","input","path","fileURLToPath","fs","path","parseYaml","mustache","text","TemplateManager","templatesPath","language","type","templatePath","configPath","configContent","error","languages","languagePath","types","validTypes","t","sourcePath","targetPath","variables","entries","entry","sourceFilePath","targetFileName","targetFilePath","content","processedContent","exec","promisify","chalk","createLogger","message","args","error","execAsync","promisify","exec","logger","createLogger","GoToolchain","projectPath","options","modulePath","exec","promisify","fs","path","execAsync","promisify","exec","logger","createLogger","JavaToolchain","javaVersion","gradleVersion","gradleVersionLine","line","error","message","projectPath","options","packagePath","srcPath","testPath","mainJavaDir","files","file","oldPath","newPath","gradlewContent","toolchains","GoToolchain","JavaToolchain","getToolchain","language","chalk","fs","logger","createLogger","__filename","fileURLToPath","__dirname","path","pkgRoot","initCommand","options","templatesPath","templateManager","TemplateManager","templates","language","promptLanguage","languageTemplates","t","type","promptType","config","variables","promptVariables","outputPath","directoryExists","templatePath","toolchain","getToolchain","stylizedOutputPath","error","select","capitalize","types","variable","value","input","dir","logger","createLogger","program","Command","output","options","initCommand","error"]}